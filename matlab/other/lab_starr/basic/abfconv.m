%function abfconv()% abfconv()% This function imports an .abf file collected by the Axon%   Assumes a sampling rate in file of 20 kHz per channel% %   Channel 1 is converted into a two binary files for spike sorting%       1) "fname.wav" = a file which can be played  -> MSD sorting (AlphaOmega)%       2) "fname.raw" = a file which can be imported into Offline Sorter (Plexon)%%   Channels 2-n (assummed to contain EMG data) are saved in "fname.mat" for subsequent merging w/ spike times%       EMG data are processed as follows:%           1) rectified%           2) low pass filtered%           3) sub-sampled -> 1 kHz (1 sample/msec)%%   The spike channel is also saved in "fname.mat" as a 1 kHz "envelope" representation%       (max & min values across 2 msec are stored in successive msec samples)%clear allfn_dir = strrep(which('abfconv'),'abfconv.m','');   % Store function location for later use
disp('**CHOOSE AN .ABF FILE AND MAKE SURE TO HIGHLIGHT ALL DESIRED CHANNELS BEFORE IMPORTING');i=1;while i    abfml % choose abf file from CD or proper directory    % Check to see if spike channel imported (AD0)    if and( size(who('*AD0')) > 0,  size(who('*Time')) > 0)        break;    end    if size(who('*AD0')) > 0        ButtonName = questdlg('Spike chan (AD0) not selected! Try again?');        switch ButtonName,        case 'No',            break        case 'Cancel',            return        end % switch    end    if size(who('*Time')) > 0        ButtonName = questdlg('Time not imported! Try again?');        switch ButtonName,        case 'No',            break        case 'Cancel',            return        end % switch    endend% Compute sampling rate of abf file (it is not always the same)if size(who('*Time')) > 0	tmp = cell2struct(who('*Time'),'name',1);	time = eval(tmp.name); % let time = [TIME array of the .abf file)    fs = round(length(time)/time(end));         % Sampling rate    RATE1 = fs/4000;  % Output EMG is first sub-sampled at 1/RATE1    RATE2 = 4000/1000;  % Output EMG is sub-sampled later at 1/RATE2else    ButtonName = questdlg('Time was not imported! Assuming 50 microsec. sampling interval.');    fs = 20000;         % Sampling rate    RATE = 20;  % Output EMG is sub-sampled later at 1/RATEend% Load filter informationfilt_file = 'abfconv_filters';load([ fn_dir filt_file ]);% If Spike channel importedif size(who('*AD0')) > 0	tmp = cell2struct(who('*AD0'),'name',1);	ad0 = eval(tmp.name); % let ad0 = [ADO array of the .abf file)	outputname = strrep(tmp.name,'_1_AD0','');	
    % Filter out HF (~9 kHz) noise common in ABF files    flt_unit = filtfilt(LowPass_5kHz_20kHz.tf.num, 1, ad0 );        % Rescale data to an appropriate range	if abs(min(flt_unit)) > max(flt_unit)         rng = abs(min(flt_unit)); % set range to largest amplitude	else         rng = max(flt_unit);	end	rng = rng*1.1;      % add a little to range to ensure we don't clip output data		%flt_unit component has the spike data	scaledad0 = (32767/rng)*flt_unit;	fid = fopen ([outputname '.raw'],'wb');		disp(['Writing spikes channel to:  ' outputname '.raw']);
	fwrite (fid,scaledad0,'int16');	fclose (fid);    disp(['Writing spikes channel to:  ' outputname '.wav']);    wavwrite((1/rng)*flt_unit,fs,16,[outputname '.wav']);    clear(tmp.name);    % Finally, remove Spk channel from memoryend% Now process EMG chans if importedif size(who('*AD*')) > 0    	% Now get EMG channels and process	tmp = cell2struct(who('*AD*'),'name',2);	[n_emg x] = size(tmp);	ndata = length(eval(tmp(1).name));    % For first down sampling from ~20kHz -> 4kHz    ndeci1 = round(ndata/RATE1);       % Length of decimated data    deci_list1 = zeros(1,ndeci1);    for i=1:ndeci1                    % Make deci_list the hard way to make sure we subsample         deci_list1(i) = round(i*RATE1);%   correctly for unusual sampling rates    end    if deci_list1(end) > length(time)    % Avoid overrun because of rounding        deci_list1(end) = length(time);    end        % For 2nd down-sampling from 4kHz -> 1 kHz    ndata1 = length(deci_list1);    deci_list2 = 1:RATE2:ndata1;        emg_chan = zeros(n_emg,length(deci_list2));        disp(['Processing ' num2str(n_emg) ' EMG/Accel channels']);	for i = 1:n_emg        ch = eval(tmp(i).name);        if i < 5            ch = detrend(ch);   % Remove offset & linear trend            rect = abs(ch);     % Compute absolute value        else            warning('NOTE!!: Assuming 5th is Accel. Not rectified');            rect = ch;        end        flt1 = filtfilt(LowPass_2kHz_20kHz.tf.num, 1, rect ); % Fist chop out > 2 kHz         deci1 = flt1(deci_list1);                             % Sub-sample down to 4 kHz        flt2 = filtfilt(LowPass_100Hz_4kHz.tf.num, 1, deci1 ); % Chop out > 100 Hz         emg_chan(i,:) = flt2(deci_list2);                     % Sub-sample down to 1 kHz        	end    outputname = [outputname '.mat'];	disp(['Writing EMG/ACCEL  channels to:  ' outputname]);    % Include time vector if imported	if size(who('*Time')) > 0        tmp = cell2struct(who('*Time'),'name',1);        time = eval(tmp.name);        time = squeeze(time(deci_list1));   % Now sub-sample        time = squeeze(time(deci_list2));   % Now sub-sample		save( outputname, 'n_emg', 'emg_chan', 'time');    else		save( outputname, 'n_emg', 'emg_chan');    endendclear all