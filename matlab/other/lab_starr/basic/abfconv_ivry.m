%function abfconv()% abfconv()% This function imports an .abf file collected by the Axon%   Assumes a sampling rate in file of 20 kHz per channel% %   Channel 1 is converted into a two binary files for spike sorting%       1) "fname.wav" = a file which can be played  -> MSD sorting (AlphaOmega)% RLM:  2) "fname.ddt" = a ddt file which is native to Plexon, for Offline Sorter% RLM:  3) "fname-accel.ddt" = an OPTIONAL ddt file containing accelerometer for accel deflection "sorting"%%   Channels 2-n (assummed to contain EMG data) are saved in "fname.mat" for subsequent merging w/ spike times%       EMG data are processed as follows:%           1) rectified%           2) low pass filtered%           3) sub-sampled -> 1 kHz (1 sample/msec)%%   The spike channel is also saved in "fname.mat" as a 1 kHz "envelope" representation%       (max & min values across 2 msec are stored in successive msec samples)%%	RLM: created by Rob Turner, %	Eited 2003.10.03 by Rory Michaelis%	RST:  revised to process TTL data channel assummed to be on 1st AUX%	channel 2005.12.05clear all% RLM: ##################################################################rename_variables = 1 % RLM: TOGGLE prompt for manually naming emg channelswrite_accel_ddt = 0  % RLM: TOGGLE writing of LAST analog channel as accelerometer DDTTTL_channel_append = '_TTL'; % default name appendage for TTL channel (in *.MAT)accel_channel_append = '_Accel'; % RLM: default name appendage for Accelerometer channel (in *.MAT)accel_ddt_append = '_a'; % RLM: name appendage for accelerometer DDT (no extension!!!)% RLM: ##################################################################fn_dir = strrep(which('abfconv2'),'abfconv2.m','');   % Store function location for later usedisp('**CHOOSE AN .ABF FILE AND MAKE SURE TO HIGHLIGHT ALL DESIRED CHANNELS BEFORE IMPORTING');i=1;while i    abfml % choose abf file from CD or proper directory    % Check to see if spike channel imported (AD0)    if and( size(who('*AD0')) > 0,  size(who('*Time')) > 0)        break;    end    if size(who('*AD0')) > 0        ButtonName = questdlg('Spike chan (AD0) not selected! Try again?');        switch ButtonName,        case 'No',            break        case 'Cancel',            return        end % switch    end    if size(who('*Time')) > 0        ButtonName = questdlg('Time not imported! Try again?');        switch ButtonName,        case 'No',            break        case 'Cancel',            return        end % switch    endend% Compute sampling rate of abf file (it is not always the same)if size(who('*Time')) > 0	tmp = cell2struct(who('*Time'),'name',1);	time = eval(tmp.name); % let time = [TIME array of the .abf file)    fs = round(length(time)/time(end));         % Sampling rate    RATE1 = fs/4000;  % Output EMG is first sub-sampled at 1/RATE1    RATE2 = 4000/1000;  % Output EMG is sub-sampled later at 1/RATE2else    ButtonName = questdlg('Time was not imported! Assuming 50 microsec. sampling interval.');    fs = 20000;         % Sampling rate    RATE = 20;  % Output EMG is sub-sampled later at 1/RATEend% Load filter informationfilt_file = 'abfconv_filters';load([ fn_dir filt_file ]);% If Spike channel importedif size(who('*AD0')) > 0    disp(['Processing spike channel.']);	tmp = cell2struct(who('*AD0'),'name',1);	ad0 = eval(tmp.name); % let ad0 = [ADO array of the .abf file)	outputname = strrep(tmp.name,'_1_AD0','');	    % Filter out HF (~9 kHz) noise common in ABF files    flt_unit = filtfilt(LowPass_5kHz_20kHz.tf.num, 1, ad0 );        % Rescale data to an appropriate range	if abs(min(flt_unit)) > max(flt_unit)         rng = abs(min(flt_unit)); % set range to largest amplitude	else         rng = max(flt_unit);	end	rng = rng*1.1;      % add a little to range to ensure we don't clip output data		%flt_unit component has the spike data	scaledad0 = (32767/rng)*flt_unit;	%	RAW file is no longer used  -  DDT file used for spike sorting	%     fid = fopen ([outputname '.raw'],'wb');		% 	disp(['Writing spikes channel to:  ' outputname '.raw']);	% 	fwrite (fid,scaledad0,'int16');	% 	fclose (fid);    disp(['Writing spikes channel to:  ' outputname '.wav']);    wavwrite((1/rng)*flt_unit,fs,16,[outputname '.wav']);	% RLM: ##################################################################    disp(['Writing spikes channel to:  ' outputname '.ddt']);	ddtdata = (32767/(max(abs(flt_unit))))*flt_unit; % +/-2047 value is from DDT format 12bit res.        writeddt(ddtdata,fs,outputname,16,'Created by abfconv_ivry.m');	% RLM: ##################################################################        clear(tmp.name);    % Finally, remove Spk channel from memoryend% Now process AUX chans if importedif size(who('*AD*')) > 0        % Now get channels and process    tmp = cell2struct(who('*AD*'),'name',2);    [n_chan x] = size(tmp);    ndata = length(eval(tmp(1).name));    % NAME CHANNELS, 64 characters per channel as per NEX channel variables.    disp(sprintf('\n\n===================================================================================='));    for i = 1:n_chan		if i == 1            varname=[num2str(i) TTL_channel_append ];		elseif i==n_chan % make "n_chan" or 5 ?            varname=[num2str(i) accel_channel_append];        else            varname=num2str(i);        end        if rename_variables            % RLM: perhaps draw small channel plot to help in naming?            disp(sprintf('\nNON-Spike Channel Number:  %d  is named:\n\t''%s''\n', i, varname));            question='WOULD YOU LIKE TO CHANGE THIS ?\nIf so, type "y" and press ENTER. If not, just press ENTER\n # > ';            choice=input(question, 's');            while ~strcmpi(choice, '')                if strcmpi(choice, 'y')                    varname = input('\nType new VARIABLE NAME now. REMEMBER, ONLY 64 CHARACTERS WILL BE WRITTEN!\n # > ', 's');                    choice = '';                else                    choice=input(question, 's');                end            end        end        varname=deblank(varname);        varnamesize=length(varname);        if varnamesize < 64            empty = 64 - varnamesize;            empty = char(zeros(1, empty));            varname = char([varname empty]);        else            varname = varname(1:64);        end        chan_names(i,:) = varname;	end    % For first down sampling from ~20kHz -> 4kHz    ndeci1 = round(ndata/RATE1);       % Length of decimated data    deci_list1 = zeros(1,ndeci1);    for i=1:ndeci1                    % Make deci_list the hard way to make sure we subsample         deci_list1(i) = round(i*RATE1);%   correctly for unusual sampling rates    end    if deci_list1(end) > length(time)    % Avoid overrun because of rounding        deci_list1(end) = length(time);    end        % For 2nd down-sampling from 4kHz -> 1 kHz    ndata1 = length(deci_list1);    deci_list2 = 1:RATE2:ndata1;        aux_chan = zeros(n_chan,length(deci_list2));        disp(['Processing ' num2str(n_chan) ' TTL/EMG/Accel channels']);	for i = 1:n_chan        ch = eval(tmp(i).name);        if i>1 & i<5            ch = detrend(ch);   % Remove offset & linear trend            rect = abs(ch);     % Compute absolute value - necessary before lp filtering EMG        else            warning('NOTE!!: Assuming 1st channel is TTL & 5th is Accel. Not rectified');            rect = ch;		end		if i>1	        flt1 = filtfilt(LowPass_2kHz_20kHz.tf.num, 1, rect ); % Fist chop out > 2 kHz 	        deci1 = flt1(deci_list1);                             % Sub-sample down to 4 kHz		else			deci1 = rect(deci_list1);		end		if i>1	        flt2 = filtfilt(LowPass_100Hz_4kHz.tf.num, 1, deci1 ); % Chop out > 100 Hz 			aux_chan(i,:) = flt2(deci_list2);                     % Sub-sample down to 1 kHz        		else			aux_chan(i,:) = deci1(deci_list2);		end	end    outputname = [outputname '.mat'];	disp(['Writing TTL/EMG/ACCEL  channels to:  ' outputname]);    % Include time vector if imported	if size(who('*Time')) > 0        tmp = cell2struct(who('*Time'),'name',1);        time = eval(tmp.name);        time = squeeze(time(deci_list1));   % Now sub-sample        time = squeeze(time(deci_list2));   % Now sub-sample		save( outputname, 'n_chan', 'aux_chan', 'time', 'chan_names'); % RLM: added channel names    else		save( outputname, 'n_chan', 'aux_chan', 'chan_names'); % RLM: added channel names    end     % RLM: ##################################################################        if write_accel_ddt        ddtdata = 32767/max(abs(aux_chan(n_chan,:))) * aux_chan(n_chan,:); % fill 16 bit integral spectrum        writeddt(ddtdata,1000,[outputname(1:end-4) accel_ddt_append],16,'ACCELEROMETER DDT created by abfconv2.m');    end% RLM: ##################################################################    end%clear all