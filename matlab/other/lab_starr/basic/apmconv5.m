%function abfconv4()% abfconv4()% This function imports an .abf file collected by the Axon%   Assumes a sampling rate in file of 20 kHz per channel% %   Channel 1 is converted into a two binary files for spike sorting%       1) "fname.wav" = a file which can be played  -> MSD sorting (AlphaOmega)%       2) "fname.raw" = a file which can be imported into Offline Sorter (Plexon)% RLM:  3) "fname.ddt" = a ddt file which is native to Plexon, for Offline Sorter% RLM:  4) "fname-accel.ddt" = an OPTIONAL ddt file containing accelerometer for accel deflection "sorting"%%   Channels 2-n (assummed to contain EMG data) are saved in "fname.mat" for subsequent merging w/ spike times%       EMG data are processed as follows:%           1) rectified%           2) low pass filtered%           3) sub-sampled -> 1 kHz (1 sample/msec)%%   The spike channel is also saved in "fname.mat" as a 1 kHz "envelope" representation%       (max & min values across 2 msec are stored in successive msec samples)%% RLM: created by Rob Turner, last edited 2003.10.03 by Rory Michaelis%% AB: modified to use APMReadData.m Matlab script for loading GL4K data in APM format%     Note: Accelerometer data is not saved any more along with the EMG%     data in a .mat file, since the sampling frequencies may be different%     of the two type of channels. The accel data is saved in a separate%     .mat file with the same suffix as the accel DDT file.% - Andrei Barborica, FHC Inc, 2007% clear allclose allcolordef(0,'white');% RLM: ##################################################################rename_variables = 1; % RLM: TOGGLE prompt for manually naming emg channelswrite_accel_ddt = 1;  % RLM: TOGGLE writing of LAST analog channel as accelerometer DDTecog_channel_append = '_Ecog'; %  SS: default name appendage for ecog channel accel_channel_append = '_Accel'; % RLM: default name appendage for Accelerometer channel (in *.MAT)accel_ddt_append = '_a'; % RLM: name appendage for accelerometer DDT (no extension!!!)% RLM: ##################################################################% AB: additional paths%addpath('../../../Guideline4000/MatlabScripts/DataImport/');   % Need to%add APMDataImport.m script to the path% AB: GL4K aux ADC values are usigned. When the AUX inputs are configured% as bipolar, Need to substract midpoint, in order to obtain a bipolar value.% When configures as unipolar, do not substract anything%auxADCzero = 8192;  % For bipolar input configurationauxADCzero = 0;   % For unipolar input configurationfn_dir = strrep(which('abfconv2'),'abfconv2.m','');   % Store function location for later usedisp('**CHOOSE AN .ABF FILE AND MAKE SURE TO HIGHLIGHT ALL DESIRED CHANNELS BEFORE IMPORTING');while true    %d='../../../Data/'; % AB: test dir    %fn='Wav11.apm'; % AB: test file name    %fn='TESTUCSF.apm'; % AB: test file name    [fn d]=uigetfile('*.apm','FHC APM files (*.apm)'); % choose abf file from CD or proper directory    try        try            apmdata;            disp('Data is already loaded, type ''clear apmdata'' to force reloading');        catch            apmdata=APMReadData([d fn]);        end;        % Rename the variables according the way abfml.dll was originally doing it        n_spike = length(apmdata.channels);        n_aux = length(apmdata.aux);        %vn=strrep(fn,'.abf','');   % This could alter the file name assuming that the substring '.abf' occurs in the actual file name as well, not only as the extension        vn=strrep(fn,'.apm','');   % This could alter the file name assuming that the substring '.abf' occurs in the actual file name as well, not only as the extension        episode=1;  % This is for ABF file format conpatibility        % First deal with spike channels        j=0;        spike_channel = [];        for i=1:n_spike            if (~isempty(apmdata.channels(i).continuous))                j=j+1;                spike_channel(j).data = apmdata.channels(i).voltage_calibration(1) * apmdata.channels(i).continuous.';                spike_channel(j).time = apmdata.channels(i).time_calibration * 1e-6 * (apmdata.channels(i).start_continuous - apmdata.channels(i).start_trial(1) + (1:length(apmdata.channels(i).continuous)) - 1);                spike_channel(j).sampfreq = round(1e6/apmdata.channels(i).time_calibration);                % Data is aligned with the gate-on/start-of-trial timestamp, may result in negative numbers as digital filter introduces a delay equal to the num taps / 2                ix = find( spike_channel(j).time < 0 );                if ~isempty(ix)                    spike_channel(j).data(ix) = [];                    spike_channel(j).time(ix) = [];                end;            end;        end;        n_spike = j;  % Update the number of channels based on what channels acutally held data        % Next, deal with aux channels        j=0;        aux_channel = [];        for i=1:n_aux            for k=1:length(apmdata.aux(i).input)                if (~isempty(apmdata.aux(i).input(k).continuous))                    j=j+1;                    aux_channel(j).data = apmdata.aux(i).voltage_calibration(1)*(apmdata.aux(i).input(k).continuous-auxADCzero);                    aux_channel(j).time = apmdata.aux(i).time_calibration * 1e-6 * (apmdata.aux(i).input(k).start_continuous - apmdata.aux(i).start_trial(1) + (1:length(apmdata.aux(i).input(k).continuous)) - 1);                    aux_channel(j).sampfreq = round(1e6/apmdata.aux(i).time_calibration);                    % Data is aligned with the gate-on/start-of-trial timestamp, may result in negative numbers as data recording may start before receiving the gate pulse                    % Also, recording on the aux channels may continue a little bit beyond the point where the spike recording has stopped. Remove that interval as well.                    ix = find(( aux_channel(j).time < 0 ) | (aux_channel(j).time > spike_channel(1).time(end)));                    if ~isempty(ix)                        aux_channel(j).data(ix) = [];                        aux_channel(j).time(ix) = [];                    end;                end;            end;        end;             n_aux = j;  % Update the number of channels based on what channels acutally held data                %clear apmdata        break;    catch        disp('Could not load data file, reason:');        disp(lasterr);        s=input('Retry (y/n) [y]','s');    	if (upper(s)=='N')            error('Canceled by user.');        end;    end;endh = figure;n_spike = length(spike_channel);for i =1:n_spike    subplot(n_spike,1,i)    plot(spike_channel(i).time,spike_channel(i).data);    title(['Spike Chan' num2str(i)]);endspike_ch = 0;while isempty(spike_ch) | min(spike_ch) < 1 | max(spike_ch) > n_spike    spike_ch = input('Enter channel #s for spike data (format: [1 2 ...]): ');endif ~isempty(spike_channel)    for i=spike_ch        if (length(spike_ch)>1)            outputname = sprintf('%s%d',vn,i); % Use var name + channel number        else            outputname = vn;    % Use var name        end;    	disp(['Writing SPIKE channel to:  ' outputname]);    	ddtdata = (32767/(max(abs(spike_channel(i).data))))*spike_channel(i).data; % +/-2047 value is from DDT format 12bit res.            writeddt(ddtdata,spike_channel(i).sampfreq,outputname,16,'Creating ddt file.');    end;end;% Close figureif exist('h','var')    if ishandle(h)        close( h )    endend% Include all remaining spike channels in the list of auxiliary channels, since they may hold good EMG data, recorded directly using an electrode (not through a preamp)for i =1:n_spike    if (i~=spike_ch)        n_aux=n_aux+1;        aux_channel(n_aux) = spike_channel(i);    end;end;% Now process EMG/ACCEL chans if importedh = figure;for i =1:n_aux    subplot(n_aux,1,i)    plot(aux_channel(i).time,aux_channel(i).data);    title(['Aux Chan' num2str(i)]);end% Now get EMG channels and processecog_ch = [];emg_ch = [];ecog_ch = input('Enter channel #s (if any) for good ECOG (format: [1 2 ...]): ');emg_ch = input('Enter channel #s (if any) for good EMG (format: [1 2 ...]): ');accel_ch = input('Enter channel # for ACCEL: ');% RLM: ##################################################################        % NAME CHANNELS, 64 characters per channel as per NEX channel variables.    disp(sprintf('\n\n===================================================================================='));    for i = [emg_ch accel_ch]        if i==accel_ch % make "n_emg" or 5 ?            varname=[num2str(i) accel_channel_append];        else            varname=num2str(i);        end        if rename_variables            % RLM: perhaps draw small channel plot to help in naming?            disp(sprintf('\nNON-Spike Channel Number:  %d  is named:\n\t''%s''\n', i, varname));            question='WOULD YOU LIKE TO CHANGE THIS ?\nIf so, type "y" and press ENTER. If not, just press ENTER\n # > ';            choice=input(question, 's');            while ~strcmpi(choice, '')                if strcmpi(choice, 'y')                    varname = input('\nType new VARIABLE NAME now. REMEMBER, ONLY 64 CHARACTERS WILL BE WRITTEN!\n # > ', 's');                    choice = '';                else                    choice=input(question, 's');                end            end        end        varname=deblank(varname);        varnamesize=length(varname);        if varnamesize < 64            empty = 64 - varnamesize;            empty = char(zeros(1, empty));            varname = char([varname empty]);        else            varname = varname(1:64);        end        aux_names(i,:) = varname;    end% RLM: ##################################################################        n_emg = length(emg_ch);    disp(['Processing ' num2str(n_emg) ' EMG/Accel channels']);    emg_chan = [];    time = [];    j = 1;	for i = emg_ch        if (isempty(time) || (length(time) == length(aux_channel(i).time)))            aux_channel(i).data = detrend(aux_channel(i).data);		% Remove offset & linear trend            aux_channel(i).data = abs(aux_channel(i).data);			% Compute absolute value            emg_chan(j,:) = aux_channel(i).data;                    % For compatibility with the original script; works only when the sampling rates on all emg channels is the same            emg_names(j,:) = aux_names(i,:);                        % For compatibility with the original script            time = aux_channel(i).time;                             % For compatibility with the original script            j = j + 1;        else            disp(sprintf('WARNING: EMG channel %d does not have the same sampling frequency like the other channels! Channel will be skipped!',i));        end;	end    outputname = [outputname '.mat'];	disp(['Writing EMG  channels to:  ' outputname]);    save( outputname, 'n_emg', 'emg_chan', 'time', 'emg_names'); % RLM: added channel names    n_accel = length(accel_ch);    disp(['Processing ' num2str(n_accel) ' Accel channels']);    accel_chan = [];    time = [];    j = 1;	for i = accel_ch        if (isempty(time) || (length(time) == length(aux_channel(i).time)))            accel_chan(j,:) = aux_channel(i).data;                    % For compatibility with the original script; works only when the sampling rates on all emg channels is the same            accel_names(j,:) = aux_names(i,:);                        % For compatibility with the original script            time = aux_channel(i).time;                               % For compatibility with the original script            j = j + 1;        else            disp(sprintf('WARNING: ACCEL channel %d does not have the same sampling frequency like the other channels! Channel will be skipped!',i));        end;	end	disp(['Writing ACCEL  channels to:  ' outputname(1:end-4) accel_ddt_append '.mat']);    % Include time vector if imported    save( [outputname(1:end-4) accel_ddt_append '.mat'], 'n_accel', 'accel_chan', 'time', 'accel_names'); % RLM: added channel names     % RLM: ##################################################################       % AB: As originally written, the code is going to fail if more than one accel channel is present    if write_accel_ddt        ddtdata = 32767/max(abs(aux_channel(accel_ch).data)) * aux_channel(accel_ch).data; % fill 16 bit integral spectrum        writeddt(ddtdata,aux_channel(accel_ch).sampfreq,[outputname(1:end-4) accel_ddt_append],16,'ACCELEROMETER DDT created by abfconv4.m');    end% RLM: ##################################################################    % Close figureif exist('h','var')    if ishandle(h)        close( h )    endend%clear all