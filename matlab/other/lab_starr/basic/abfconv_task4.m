%  abfconv_task()%% This function imports an .abf file collected by the Axon%   Assumes a sampling rate in file of 20 kHz per channel% %   Channel 1 is converted into a two binary files for spike sorting%       1) "fname.wav" = a file which can be played  -> MSD sorting (AlphaOmega)%       2) "fname.raw" = a file which can be imported into Offline Sorter (Plexon)% RLM:  3) "fname.ddt" = a ddt file which is native to Plexon, for Offline Sorter% RLM:  4) "fname-accel.ddt" = an OPTIONAL ddt file containing accelerometer for accel deflection "sorting"%%   Channels 2-n (assummed to contain EMG data) are saved in "fname.mat" for subsequent merging w/ spike times%       EMG data are processed as follows:%           1) rectified%           2) low pass filtered%           3) sub-sampled -> 1 kHz (1 sample/msec)%%   The spike channel is also saved in "fname.mat" as a 1 kHz "envelope" representation%       (max & min values across 2 msec are stored in successive msec samples)%% RLM: created by Rob Turner, last edited 2003.10.03 by Rory Michaelis% Revised to not filter channel 5 - contains event data%% AB: modified to use APMReadData.m Matlab script (instead of abfload.m, like abfconv_task3)% - Andrei Barborica, FHC Inc, 2007% AB: additional paths%addpath('../../../Guideline4000/MatlabScripts/DataImport/');   % Need to%add APMDataImport.m script to the pathclear allclose allcolordef(0,'white');% AB: GL4K aux ADC values are usigned. When the AUX inputs are configured% as bipolar, Need to substract midpoint, in order to obtain a bipolar value.% When configures as unipolar, do not substract anything%auxADCzero = 8192;  % For bipolar input configurationauxADCzero = 0;   % For unipolar input configurationfn_dir = strrep(which('abfconv2'),'abfconv2.m','');   % Store function location for later usedisp('**CHOOSE AN .ABF FILE AND MAKE SURE TO HIGHLIGHT ALL DESIRED CHANNELS BEFORE IMPORTING');while true    % AB:    %d='../../../Data/'; % AB: test dir    %fn='TESTUCSF.apm'; % AB: test file name    [fn d]=uigetfile('*.apm','FHC APM files (*.apm)'); % choose abf file from CD or proper directory    try        try            apmdata;            disp('Data is already loaded, type ''clear apmdata'' to force reloading');        catch            apmdata=APMReadData([d fn]);        end;        % Rename the variables according the way abfml.dll was originally doing it        n_spike = length(apmdata.channels);        n_aux = length(apmdata.aux);        %vn=strrep(fn,'.abf','');   % This could alter the file name assuming that the substring '.abf' occurs in the actual file name as well, not only as the extension        vn=strrep(fn,'.apm','');   % This could alter the file name assuming that the substring '.abf' occurs in the actual file name as well, not only as the extension        episode=1;  % This is for ABF file format conpatibility        % First deal with spike channels        j=0;        spike_channel = [];        for i=1:n_spike            if (~isempty(apmdata.channels(i).continuous))                j=j+1;                spike_channel(j).data = apmdata.channels(i).continuous.';                spike_channel(j).time = apmdata.channels(i).time_calibration * 1e-6 * (apmdata.channels(i).start_continuous - apmdata.channels(i).start_trial(1) + (1:length(apmdata.channels(i).continuous)) - 1);                spike_channel(j).sampfreq = round(1e6/apmdata.channels(i).time_calibration);                % Data is aligned with the gate-on/start-of-trial timestamp, may result in negative numbers as digital filter introduces a delay equal to the num taps / 2                ix = find( spike_channel(j).time < 0 );                if ~isempty(ix)                    spike_channel(j).data(ix) = [];                    spike_channel(j).time(ix) = [];                end;            end;        end;        n_spike = j;  % Update the number of channels based on what channels acutally held data        % Next, deal with aux channels        j=0;        aux_channel = [];        for i=1:n_aux            for k=1:length(apmdata.aux(i).input)                if (~isempty(apmdata.aux(i).input(k).continuous))                    j=j+1;                    aux_channel(j).data = apmdata.aux(i).voltage_calibration(1)*(apmdata.aux(i).input(k).continuous.'-auxADCzero);                    aux_channel(j).time = apmdata.aux(i).time_calibration * 1e-6 * (apmdata.aux(i).input(k).start_continuous - apmdata.aux(i).start_trial(1) + (1:length(apmdata.aux(i).input(k).continuous)) - 1);                    aux_channel(j).sampfreq = round(1e6/apmdata.aux(i).time_calibration);                    % Data is aligned with the gate-on/start-of-trial timestamp, may result in negative numbers as data recording may start before receiving the gate pulse                    % Also, recording on the aux channels may continue a little bit beyond the point where the spike recording has stopped. Remove that interval as well.                    ix = find(( aux_channel(j).time < 0 ) | (aux_channel(j).time > spike_channel(1).time(end)));                    if ~isempty(ix)                        aux_channel(j).data(ix) = [];                        aux_channel(j).time(ix) = [];                    end;                end;            end;        end;                n_aux = j;  % Update the number of channels based on what channels acutally held data                %clear apmdata        break;    catch        disp('Could not load data file, reason:');        disp(lasterr);        s=input('Retry (y/n) [y]','s');    	if (upper(s)=='N')            error('Canceled by user.');        end;    end;    endh = figure;n_spike = length(spike_channel);for i =1:n_spike    subplot(n_spike,1,i)    plot(spike_channel(i).time,spike_channel(i).data);    title(['Spike Chan' num2str(i)]);endspike_ch = 0;while isempty(spike_ch) | min(spike_ch) < 1 | max(spike_ch) > n_spike    spike_ch = input('Enter channel #s for spike data (format: [1 2 ...]): ');endif ~isempty(spike_channel)    for i=spike_ch        if (length(spike_ch)>1)            outputname = sprintf('%s%d',vn,i); % Use var name + channel number        else            outputname = vn;    % Use var name        end;    	ddtdata = (32767/(max(abs(spike_channel(i).data))))*spike_channel(i).data; % +/-2047 value is from DDT format 12bit res.            writeddt(ddtdata,spike_channel(i).sampfreq,outputname,16,'Creating ddt file.');    end;end;% Close figureif exist('h','var')    if ishandle(h)        close( h )    endend% Include all remaining spike channels in the list of auxiliary channels, since they may hold good EMG data, recorded directly using an electrode (not through a preamp)for i =1:n_spike    if (i~=spike_ch)        n_aux=n_aux+1;        aux_channel(n_aux) = spike_channel(i);    end;end;% Now process AUX chans, if imported	h = figure;    n_aux = length(aux_channel);	for i =1:n_aux		subplot(n_aux,1,i)		plot(aux_channel(i).time,aux_channel(i).data);		title(['Aux Chan' num2str(i)]);	end		% Select Event channel	evt_ch = 0;	while evt_ch < 1 | evt_ch > n_aux		evt_ch = input('Enter channel # for Task Events: ');	end	emg_ch = [];	emg_ch = input('Enter channel #s (if any) for good EMG (format: [1 2 ...]): ');	accel_ch = input('Enter channel # for ACCEL: ');	if exist('h','var')		if ishandle(h)			close( h )		end	end        fprintf('Processing  %d  EMG/Event/Accel channels', n_aux);    n_emg = length(emg_ch);    emg_chan = [];    emg_time = [];    j = 1;	for i = emg_ch        if (isempty(emg_time) || (length(emg_time) == length(aux_channel(i).time)))            % Detrend and rectify the EMG channels (only)            aux_channel(i).data = detrend(aux_channel(i).data);		% Remove offset & linear trend            aux_channel(i).data = abs(aux_channel(i).data);			% Compute absolute value            emg_chan(j,:) = aux_channel(i).data;                    % For compatibility with the original script; works only when the sampling rates on all emg channels is the same            emg_time = aux_channel(i).time;                          % For compatibility with the original script            j = j + 1;        else            disp(sprintf('WARNING: EMG channel %d does not have the same sampling frequency like the other channels! Channel will be skipped!',i));        end;		fprintf('.');	end        % Event channels    n_evt = length(evt_ch);    evt_chan = [];    evt_time = [];    j = 1;	for i = evt_ch        if (isempty(evt_time) || (length(evt_time) == length(aux_channel(i).time)))            evt_chan(j,:) = aux_channel(i).data;                    % For compatibility with the original script; works only when the sampling rates on all emg channels is the same            evt_time = aux_channel(i).time;                         % For compatibility with the original script            j = j + 1;        else            disp(sprintf('WARNING: EVT channel %d does not have the same sampling frequency like the other channels! Channel will be skipped!',i));        end;		fprintf('.');    end    % Accel channels    n_accel = length(accel_ch);    accel_chan = [];    accel_time = [];    j = 1;	for i = accel_ch        if (isempty(accel_time) || (length(accel_time) == length(aux_channel(i).time)))            accel_chan(j,:) = aux_channel(i).data;                     % For compatibility with the original script; works only when the sampling rates on all emg channels is the same            accel_time = aux_channel(i).time;                          % For compatibility with the original script            j = j + 1;        else            disp(sprintf('WARNING: ACCEL channel %d does not have the same sampling frequency like the other channels! Channel will be skipped!',i));        end;		fprintf('.');	end	fprintf('\n');	% Detect events	events = ParseIntraopEvents(aux_channel(evt_ch).time,aux_channel(evt_ch).data);    if ~isempty(events) & ~isempty(accel_ch) & accel_ch>0 & accel_ch<=n_aux        events = DetectAccels3(aux_channel(accel_ch).time,aux_channel(accel_ch).data,events);    end		    outputname = [outputname '.mat'];	disp(['Writing EMG/ACCEL  channels to:  ' outputname]);	save( outputname, 'n_emg', 'emg_chan', 'emg_time', 'n_accel', 'accel_chan', 'accel_time', 'n_evt', 'evt_chan', 'evt_time', 'events');    % Close figure    if exist('h','var')        if ishandle(h)            close( h )        end    end    